# Next-js
Learning Next js..

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, navigate to the project you want to run:

```bash
cd basics
# or
cd intermediate
# or
cd stackagentsnext
```
Then, run the development server:

```
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```
Open http://localhost:3000 with your browser to see the result.



## üìñ Topics Covered In This Repository
This repository covers a wide range of Next.js concepts, from the fundamentals to advanced features, based on a comprehensive video tutorial.

## Fundamentals
1. Project Structure & Routing: Hello World, Project Structure, File-based Routing, Nested Routes, Dynamic Routes, Catch-all Segments, and the Not Found Page.

 2. rganizing Code: File Colocation, Private Folders (_lib), and Route Groups ((folder)).

3. UI & Layouts: Layouts, Nested Layouts, Multiple Root Layouts, and Templates.

4. Metadata: Static and dynamic metadata, including page titles.

5. Navigation: The Link Component, Active Links, Programmatic Navigation, and accessing params and searchParams.

6. Error Handling: error.tsx, not-found.tsx, recovering from errors, and handling errors in nested routes, layouts, and globally.

7. UI Patterns: Loading UI (loading.tsx), Parallel Routes, Unmatched Routes, Conditional Routes, and Intercepting Routes.

8. Intermediate & Advanced Topics
Route Handlers (API Routes): Handling GET, POST, PATCH, and DELETE requests, Dynamic Route Handlers, URL Query Parameters, and working with Headers, Cookies, and Redirects.

9. Caching: Caching in Route Handlers.

10. Middleware: Executing code before a request is completed.

11. Rendering: Understanding Client-side Rendering (CSR), Server-side Rendering (SSR), and Suspense with SSR.

12. React Server Components: An overview of the new paradigm in React and Next.js.

**üìö Part 1:** Next.js Core Concepts (from the basics project)
This section covers the fundamental concepts of the Next.js App Router.

### 1. App Router and File-based Routing
The App Router uses a directory-based structure. UI is created by nesting layouts and pages.

1. app/layout.tsx: The root layout.

2. app/page.tsx: The home page.

3. app/products/page.tsx: Corresponds to the /products route.

4. Private Folders: Folders prefixed with an underscore (e.g., _lib) are private and cannot be accessed via the URL, making them ideal for utility functions and components.

Example: Home Page `(basics/src/app/page.tsx)`
```
import Link from "next/link";

export default function Home() {
  return (
    <>
      <h1>Welcome Home</h1>
      <Link href="/blog">Blog</Link>
      <Link href="/products">Products</Link>
    </>
  );
}
```

### 2. Layouts and Templates
1. Layouts: Reusable UI that wraps page components. They preserve state and do not re-render on navigation.

2. Templates: Similar to layouts but create a new instance for each child on navigation, meaning state is not preserved. Useful for animations or logic that needs to run on every page view.

Example: Root Layout `(basics/src/app/layout.tsx)`
```
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};


export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <header style={{ backgroundColor: "lightblue", padding: "1rem" }}>
          <p>Header</p>
        </header>
        {children}
        <footer style={{ backgroundColor: "ghostwhite", padding: "1rem" }}>
          <p>Footer</p>
        </footer>
      </body>
    </html>
  );
}
```

### 3. Dynamic and Catch-all Routes

`Dynamic Routes` [folderName]: Create pages from dynamic data (e.g., [productId]).

`Catch-all Routes` `[...folderName]:` Catch all subsequent segments.

`Optional Catch-all`: [[...folderName]]: Also includes the root of the segment.

Example: `Docs Page (basics/src/app/docs/[[...slug]]/page.tsx)`
```
export default function Docs({ params }: { params: { slug: string[] } }) {
  if (params.slug?.length === 2) {
    return (
      <h1>
        Viewing docs for feature {params.slug[0]} and concept {params.slug[1]}
      </h1>
    );
  } else if (params.slug?.length === 1) {
    return <h1>Viewing docs for feature {params.slug[0]}</h1>;
  }
  return <h1>Docs Home Page</h1>;
}
```
### 4. Error Handling, Loading UI, and Not Found
1. loading.tsx: Automatically shows a loading UI using React Suspense while a route segment is loading.

2. error.tsx: Catches and handles errors in nested routes, providing a fallback UI. Must be a Client Component.

3. not-found.tsx: Renders when a route is not found.

4. global-error.tsx: A special file to handle errors in the root layout.

### 5. Advanced Routing: Parallel and Intercepting Routes
1. Parallel Routes (@folder): Render multiple pages in the same layout simultaneously. Great for dashboards.

2. Intercepting Routes ((.), (..), (...)): Display a route's content within the current layout without a full page navigation, perfect for modals.

**üõ†Ô∏è Part 2:** Intermediate Concepts (from the intermediate project)
This section covers server-side logic, rendering control, and other advanced features.

### 1. Route Handlers (API Routes)
Create API endpoints using route.ts or route.js files. They support standard HTTP methods.

Example: GET Request (intermediate/src/app/profiledata/api/route.ts)
```
import { type NextRequest } from "next/server";

export async function GET(request: NextRequest) {
    const requestHeaders = new Headers(request.headers)
    console.log(requestHeaders.get("Authorization"))
    return new Response("<h1>Profile API data</h1>",{
        headers:{
            "Content-Type": "text/html",
            "Set-Cookie": "theme=dark"
        }
    });
}
```
### 2. Middleware
A middleware.ts file allows you to run code before a request is completed, useful for authentication, redirects, or modifying request headers.

Example: Basic Middleware (intermediate/src/middleware.ts)
```
import { NextResponse, type NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  if (request.nextUrl.pathname === "/profile") {
    return NextResponse.redirect(new URL("/hello", request.url));
  }
}
```
### 3. Rendering Strategies & Caching
Rendering: Next.js uses React Server Components by default. You can opt into Client Components with the "use client" directive.

SSR vs. CSR: Choose between Server-side Rendering (for dynamic data) and Client-side Rendering (for interactive UI).

Caching: Route Handlers are cached by default. You can opt out for dynamic data fetching.

Example: Dynamic Route (intermediate/src/app/time/route.ts)
```
export const dynamic = "force-dynamic"; // Opt out of caching

export async function GET() {
  return Response.json({
    time: new Date().toLocaleTimeString(),
  });
}
```

### ü§ñ Part 3: stackagentsnext Project
This project is a more complete application that demonstrates how to structure a real-world Next.js app.

1. Key Features:
Authentication Flow: A complete user authentication system with pages for login, registration, and password recovery, organized using route groups.

2. Component-Based Architecture: The UI is built using reusable React components located in the src/app/components directory (e.g., Header, Footer, Main).

3. CSS Modules for Styling: Each component and page has its own scoped CSS file (.module.css), preventing style conflicts and improving maintainability.

Example: Login Component (stackagentsnext/src/app/(Auth)/login/login.tsx)
```
"use client";
import { useState } from "react";
import styles from "./login.module.css";

const LoginForm = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  // ... form handling logic
  
  return (
    <form className={styles.form}>
      {/* Form inputs */}
    </form>
  );
};

export default LoginForm;
```